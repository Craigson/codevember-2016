<!doctype html>
<html lang="en">
	<head>
		<title>Greeble AO</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="screen" />
		<link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Slab" rel="stylesheet">

	</head>
	<body>

		<div id="container"></div>
		<div id="info" >
			<p><a href="../27" >Previous</a> | <a href="../29" >Next</a></p>
			<h1>28. Greeble AO</h1>
			<p><a href="https://clicktorelease.com/code/codevember-2016/" >See other experiments for Codevember 2016</a></p>
		</div>

		<script src="../js/three.js"></script>
		<script src="../js/OrbitControls.js"></script>
		<script src="../js/Maf.js"></script>
		<script src="../js/THREE.FBOHelper.js"></script>
		<script src="../js/GeometryUtils.js"></script>

<script type="x-shader/x-vertex" id="ortho-vs" >
precision highp float;

attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

uniform mat3 normalMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

mat3 toMat3(mat4 m4) {
  return mat3(
      m4[0][0], m4[0][1], m4[0][2],
      m4[1][0], m4[1][1], m4[1][2],
      m4[2][0], m4[2][1], m4[2][2]);
}

void main() {

	vUv = uv;
	vNormal = toMat3( modelViewMatrix ) * normal;

	vec4 p = modelViewMatrix * vec4( position, 1. );
	vPosition = p.xyz;

	gl_Position = projectionMatrix * p;

}
</script>

<script type="x-shader/x-fragment" id="buffer-fs" >
precision highp float;

uniform float type;
uniform float linearDepth;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

void main() {

	if( type == 0. ){
		vec3 normal = normalize( vNormal );
		gl_FragColor = vec4( normal, 1. );
	} else {
		float lDepth = length( vPosition ) / linearDepth;
		gl_FragColor = vec4( vPosition, lDepth );
	}

}

</script>

<script type="x-vertex/x-fragment" id="ssao-fs" >

/// <summary>
/// This fragment shader calculates the ambient occlusion contributions for each fragment.
/// This shader requires:
/// 1. View-space position buffer
/// 2. View-space normal vector buffer
/// 3. Normalmap to preturb the sampling kernel
/// </summary>


#ifdef GL_ES
	precision highp float;
#endif


/// <summary>
/// Texture samples used by this shader.
/// <summary>
uniform sampler2D Sample0;	// View space position data
uniform sampler2D Sample1;	// View space normal vectors
uniform sampler2D Sample2;	// Normalmap to randomize the sampling kernel
vec2 TexelSize;
uniform vec2 resolution;

/// <summary>
/// Occluder bias to minimize self-occlusion.
/// <summary>
uniform float OccluderBias;


/// <summary>
/// Specifies the size of the sampling radius.
/// <summary>
uniform float SamplingRadius;


/// <summary>
/// Ambient occlusion attenuation values.
/// These parameters control the amount of AO calculated based on distance
/// to the occluders. You need to play with them to find the right balance.
///
/// .x = constant attenuation. This is useful for removing self occlusion. When
///		 set to zero or a low value, you will start to notice edges or wireframes
///		 being shown. Typically use a value between 1.0 and 3.0.
///
///	.y = linear attenuation. This provides a linear distance falloff.
/// .z = quadratic attenuation. Smoother falloff, but is not used in this shader.
/// <summary>
uniform vec2 Attenuation;


/// <summary>
/// Varying variables.
/// <summary>
varying vec2 vUv;


/// <summary>
/// Sample the ambient occlusion at the following UV coordinate.
/// <summary>
/// <param name="srcPosition">3D position of the source pixel being tested.</param>
/// <param name="srcNormal">Normal of the source pixel being tested.</param>
/// <param name="uv">UV coordinate to sample/test for ambient occlusion.</param>
/// <returns>Ambient occlusion amount.</returns>
float SamplePixels (vec3 srcPosition, vec3 srcNormal, vec2 uv)
{
	// Get the 3D position of the destination pixel
	vec3 dstPosition = texture2D(Sample0, uv).xyz;

	// Calculate ambient occlusion amount between these two points
	// It is simular to diffuse lighting. Objects directly above the fragment cast
	// the hardest shadow and objects closer to the horizon have minimal effect.
	vec3 positionVec = dstPosition - srcPosition;
	float intensity = max(dot(normalize(positionVec), srcNormal) - OccluderBias, 0.0);

	// Attenuate the occlusion, similar to how you attenuate a light source.
	// The further the distance between points, the less effect AO has on the fragment.
	float dist = length(positionVec);
	float attenuation = 1.0 / (Attenuation.x + (Attenuation.y * dist));

	return intensity * attenuation;
}

float random(vec2 n, float offset ){
	return .5 - fract(sin(dot(n.xy + vec2( offset, 0. ), vec2(12.9898, 78.233)))* 43758.5453);
}

/// <summary>
/// Fragment shader entry.
/// <summary>
void main ()
{
	TexelSize = 1. / resolution;

	// Get position and normal vector for this fragment
	vec3 srcPosition = texture2D(Sample0, vUv).xyz;
	vec3 srcNormal = texture2D(Sample1, vUv).xyz;
	//vec2 randVec = normalize(texture2D(Sample2, vUv).xy * 2.0 - 1.0);
	vec2 randVec = normalize( vec2( random( vUv, 234. ), random( vUv.yx, 43.2 ) ) );
	float srcDepth = texture2D(Sample0, vUv).w;

	// The following variable specifies how many pixels we skip over after each
	// iteration in the ambient occlusion loop. We can't sample every pixel within
	// the sphere of influence because that's too slow. We only need to sample
	// some random pixels nearby to apprxomate the solution.
	//
	// Pixels far off in the distance will not sample as many pixels as those close up.
	float kernelRadius = SamplingRadius * (1.0 - srcDepth);

	// Sample neighbouring pixels
	vec2 kernel[4];
	kernel[0] = vec2(0.0, 1.0);	// top
	kernel[1] = vec2(1.0, 0.0);	// right
	kernel[2] = vec2(0.0, -1.0);	// bottom
	kernel[3] = vec2(-1.0, 0.0);	// left

	const float Sin45 = 0.707107;	// 45 degrees = sin(PI / 4)

	// Sample from 16 pixels, which should be enough to appromixate a result. You can
	// sample from more pixels, but it comes at the cost of performance.
	float occlusion = 0.0;
	for (int i = 0; i < 4; ++i)
	{
		vec2 k1 = reflect(kernel[i], randVec);
		vec2 k2 = vec2(k1.x * Sin45 - k1.y * Sin45,
				k1.x * Sin45 + k1.y * Sin45);
		k1 *= TexelSize;
		k2 *= TexelSize;

		occlusion += SamplePixels(srcPosition, srcNormal, vUv + k1 * kernelRadius);
		occlusion += SamplePixels(srcPosition, srcNormal, vUv + k2 * kernelRadius * 0.75);
		occlusion += SamplePixels(srcPosition, srcNormal, vUv + k1 * kernelRadius * 0.5);
		occlusion += SamplePixels(srcPosition, srcNormal, vUv + k2 * kernelRadius * 0.25);
	}

	// Average and clamp ambient occlusion
	occlusion /= 16.0;
	occlusion = clamp(occlusion, 0.0, 1.0);

	gl_FragColor = vec4( vec3( occlusion ), 1. );

}

</script>

<script type="x-vertex/x-fragment" id="combine-fs" >
precision highp float;

uniform sampler2D colorTexture;
uniform sampler2D aoTexture;

varying vec2 vUv;

void main() {

	vec3 color = texture2D(colorTexture, vUv).xyz;
	float ao = texture2D(aoTexture, vUv ).x;

	color = clamp(color - ao * length( color ), 0.0, 1.0);

	gl_FragColor.xyz = pow(color, vec3(1.0 / 2.2));
	gl_FragColor.w = 1.0;

	//gl_FragColor= vec4( vec3(1. - ao ),1. );
}
</script>

<script type="x-shader/x-fragment" id="final-fs" >
precision highp float;

uniform sampler2D inputTexture;
uniform vec2 resolution;

uniform float boost;
uniform float reduction;

uniform float amount;
uniform float time;

varying vec2 vUv;

#define FXAA_REDUCE_MIN   (1.0/128.0)
#define FXAA_REDUCE_MUL   (1.0/8.0)
#define FXAA_SPAN_MAX     8.0

float random(vec2 n, float offset ){
	return .5 - fract(sin(dot(n.xy + vec2( offset, 0. ), vec2(12.9898, 78.233)))* 43758.5453);
}

void main() {

    vec2 res = 1. / resolution;

    vec3 rgbNW = texture2D( inputTexture, ( vUv.xy + vec2( -1.0, -1.0 ) * res ) ).xyz;
    vec3 rgbNE = texture2D( inputTexture, ( vUv.xy + vec2( 1.0, -1.0 ) * res ) ).xyz;
    vec3 rgbSW = texture2D( inputTexture, ( vUv.xy + vec2( -1.0, 1.0 ) * res ) ).xyz;
    vec3 rgbSE = texture2D( inputTexture, ( vUv.xy + vec2( 1.0, 1.0 ) * res ) ).xyz;
    vec4 rgbaM  = texture2D( inputTexture,  vUv.xy  * res );
    vec3 rgbM  = rgbaM.xyz;
    vec3 luma = vec3( 0.299, 0.587, 0.114 );

    float lumaNW = dot( rgbNW, luma );
    float lumaNE = dot( rgbNE, luma );
    float lumaSW = dot( rgbSW, luma );
    float lumaSE = dot( rgbSE, luma );
    float lumaM  = dot( rgbM,  luma );
    float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );
    float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );

    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );

    float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );
    dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
          max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                dir * rcpDirMin)) * res;
    vec4 rgbA = (1.0/2.0) * (
    texture2D(inputTexture,  vUv.xy + dir * (1.0/3.0 - 0.5)) +
    texture2D(inputTexture,  vUv.xy + dir * (2.0/3.0 - 0.5)));
    vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
    texture2D(inputTexture,  vUv.xy + dir * (0.0/3.0 - 0.5)) +
    texture2D(inputTexture,  vUv.xy + dir * (3.0/3.0 - 0.5)));
    float lumaB = dot(rgbB, vec4(luma, 0.0));

    vec4 color;
    if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {
        color = rgbA;
    } else {
        color = rgbB;
    }

    vec2 position = ( gl_FragCoord.xy / resolution ) - .5;
	float vignette = length( position );
    vignette = boost - vignette * reduction;

    color.rgb *= vignette;

    color += vec4( vec3( amount * random( vUv, time ) ), 1. );

    float gamma = 1.2;
    color.rgb = pow(color.rgb, vec3(1.0/gamma));

    gl_FragColor = color;

}

</script>

<script>

'use strict';

var container, renderer, camera, controls, scene;
var mesh;

var orthoQuad, orthoCamera, orthoScene;
var colorFBO, normalFBO, positionFBO, ssaoFBO, combinedFBO;
var resolution = new THREE.Vector2();
var ssaoShader, bufferMaterial, combineShader, finalShader;
var meshes = [];

var helper;

var container = document.getElementById( 'container' );

function createRenderTarget() {

	return new THREE.WebGLRenderTarget( 1, 1, {
		wrapS: THREE.ClampToEdgeWrapping,
		wrapT: THREE.ClampToEdgeWrapping,
		format: THREE.RGBAFormat,
		stencilBuffer: false,
		depthBuffer: true
	});

}

function createFBO() {

	return new THREE.WebGLRenderTarget( 1, 1, {
		wrapS: THREE.ClampToEdgeWrapping,
		wrapT: THREE.ClampToEdgeWrapping,
		format: THREE.RGBAFormat,
		type: THREE.HalfFloatType,
		stencilBuffer: false,
		depthBuffer: true
	});

}

function initScene() {

	var light = new THREE.HemisphereLight( 0x808080, 0, .5 );
	scene.add( light );

	var light1 = new THREE.SpotLight( 0xffffff, .5, 100, 1, .2, .1 );
	light1.position.set( 5, 0, 14 );
	light1.castShadow = true;
	light1.shadow.mapSize.set( 1024, 1024 );
	scene.add( light1 );

	renderer.render( scene, camera );
	helper.attach( light1.shadow.map, 'light1' );

	bufferMaterial = new THREE.RawShaderMaterial( {
		uniforms: {
			linearDepth: { type: 'f', value: camera.far - camera.near },
			type: { type: 'f', value: 0 }
		},
		vertexShader: document.getElementById('ortho-vs').textContent,
		fragmentShader: document.getElementById('buffer-fs').textContent,
		transparent: !true
	} );

	var baseGeometry = new THREE.TorusBufferGeometry( 10, 3, 200, 36 );
	var material = new THREE.MeshStandardMaterial({
		metalness: 0,
		roughness: 1,
		side: THREE.DoubleSide
	});
	var mesh = new THREE.Mesh( baseGeometry, material );
	scene.add( mesh );
	mesh.castShadow = mesh.receiveShadow = true;

	var boxGeometry = new THREE.BoxBufferGeometry( 1,1,1 );
	var points = THREE.GeometryUtils.randomPointsInBufferGeometry( baseGeometry, 1000 );
	points.forEach( function( p ) {
		var mesh = new THREE.Mesh( boxGeometry, material );
		mesh.position.copy( p );
		mesh.rotation.set(
			Maf.randomInRange( 0, 2 * Math.PI ),
			Maf.randomInRange( 0, 2 * Math.PI ),
			Maf.randomInRange( 0, 2 * Math.PI )
		)
		mesh.scale.set(
			Maf.randomInRange( 0, 2 ),
			Maf.randomInRange( 0, 2 ),
			Maf.randomInRange( 0, 2 )
		)
		scene.add( mesh );
		mesh.castShadow = mesh.receiveShadow = true;
		meshes.push( mesh );
	});

	colorFBO = createFBO();
	positionFBO = createFBO();
	normalFBO = createFBO();
	ssaoFBO = createFBO();
	combinedFBO = createFBO();

	ssaoFBO.texture.minFilter = THREE.LinearMipMapLinearFilter;
	ssaoFBO.texture.wrapS = ssaoFBO.texture.wrapT = THREE.ClampToEdgeWrapping;

	helper.attach( colorFBO, 'color' );
	helper.attach( positionFBO, 'positions' );
	helper.attach( normalFBO, 'normals' );
	helper.attach( ssaoFBO, 'ssao' );
	helper.attach( combinedFBO, 'combined' );

	ssaoShader = new THREE.RawShaderMaterial( {
		uniforms: {
			Sample0: { type: 't', value: positionFBO.texture },
			Sample1: { type: 't', value: normalFBO.texture },
			resolution: { type: 'v2', value: resolution },
			OccluderBias: { type: 'f', value: 0.05 },
			SamplingRadius: { type: 'f', value: 20 },
			Attenuation: { type: 'v2', value: new THREE.Vector2( 1, 1 ) }
		},
		vertexShader: document.getElementById('ortho-vs').textContent,
		fragmentShader: document.getElementById('ssao-fs').textContent,
		transparent: !true
	} );

	combineShader = new THREE.RawShaderMaterial( {
		uniforms: {
			colorTexture: { type: 't', value: colorFBO.texture },
			aoTexture: { type: 't', value: ssaoFBO.texture }
		},
		vertexShader: document.getElementById('ortho-vs').textContent,
		fragmentShader: document.getElementById('combine-fs').textContent,
		transparent: !true
	} );

	finalShader = new THREE.RawShaderMaterial( {
		uniforms: {
			inputTexture: { type: 't', value: combinedFBO.texture },
			resolution: { type: 'v2', value: resolution },
			boost: { type: 'f', value: 1.1 },
			reduction: { type: 'f', value: .9 },
			amount: { type: 'f', value: .1 },
			time: { type: 'f', value: 0 }
		},
		vertexShader: document.getElementById('ortho-vs').textContent,
		fragmentShader: document.getElementById('final-fs').textContent,
	} );

	orthoScene = new THREE.Scene();
	orthoCamera = new THREE.OrthographicCamera( 1 / - 2, 1 / 2, 1 / 2, 1 / - 2, .00001, 1000 );
	orthoQuad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 1, 1 ), ssaoShader );
	orthoScene.add( orthoQuad );

}

function init() {

	container = document.getElementById( 'container' );

	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, .1, 100 );
	camera.target = new THREE.Vector3( 0, 0, 0 );
	camera.position.set( 0, 0, 20 );
	camera.lookAt( camera.target );
	scene.add( camera );

	renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setClearColor( 0, 1 );
	container.appendChild( renderer.domElement );

	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFShadowMap;

	helper = new FBOHelper( renderer );

	controls = new THREE.OrbitControls( camera, renderer.domElement );

	initScene();
	onWindowResized();

	window.addEventListener( 'resize', onWindowResized );

	animate();

}

function onWindowResized( event ) {

	var w = container.clientWidth;
	var h = container.clientHeight;

	renderer.setSize( w, h );
	camera.aspect = w / h;
	camera.updateProjectionMatrix();

	var dPR = renderer.getPixelRatio();
	resolution.set( w * dPR, h * dPR );

	var sW = Maf.nextPowerOfTwo( w ) / 2;
	var sH = Maf.nextPowerOfTwo( h ) / 2;

	colorFBO.setSize( w * dPR, h * dPR );
	positionFBO.setSize( sW, sH );
	normalFBO.setSize( sW, sH );
	ssaoFBO.setSize( sW, sH );
	combinedFBO.setSize( w * dPR, h * dPR );

	helper.setSize( w, h );

}

function animate() {

	requestAnimationFrame( animate );

	controls.update();

	meshes.forEach( function( m ) { m.rotation.y += .01 } );

	scene.overrideMaterial = null;
	renderer.render( scene, camera, colorFBO );

	scene.overrideMaterial = bufferMaterial;
	bufferMaterial.uniforms.type.value = 0;
	renderer.render( scene, camera, normalFBO );
	bufferMaterial.uniforms.type.value = 1;
	renderer.render( scene, camera, positionFBO );

	orthoQuad.material = ssaoShader;
	renderer.render( orthoScene, orthoCamera, ssaoFBO );
	orthoQuad.material = combineShader;
	renderer.render( orthoScene, orthoCamera, combinedFBO );
	orthoQuad.material = finalShader;
	renderer.render( orthoScene, orthoCamera );

	helper.update();

}

window.addEventListener( 'load', init );

</script>

	</body>
</html>
